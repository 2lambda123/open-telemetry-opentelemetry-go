---
title: Processing and Exporting Data
weight: 4
linkTitle: Exporting data
---

Once you've instrumented your code, you need to get the data out in order to do anything useful with it. This page will cover the basics of the process and export pipeline.

## Sampling

Sampling is a process that restricts the amount of traces that are generated by a system. The exact sampler you should use depends on your specific needs, but in general you should make a decision at the start of a trace, and allow the sampling decision to propagate to other services.

A sampler needs to be set on the tracer provider when its configured, as follows:

```go
provider := sdktrace.NewTracerProvider(
	sdktrace.WithSampler(sdktrace.AlwaysSample()),
)
```

`AlwaysSample` and `NeverSample` are fairly self-explanatory. Always means that every trace will be sampled, the converse holds as true for Never. When you're getting started, or in a development environment, you'll almost always want to use `AlwaysSample`.

Other samplers include:

* `TraceIDRatioBased`, which will sample a fraction of traces, based on the fraction given to the sampler. Thus, if you set this to .5, half of traces will be sampled.
* `ParentBased`, which behaves differently based on the incoming sampling decision. In general, this will sample spans that have parents that were sampled, and will not sample spans whose parents were _not_ sampled.

When you're in production, you should consider using the `TraceIDRatioBased` sampler with the `ParentBased` sampler.

## Resources

Resources are a special type of attribute that apply to all spans generated by a process. These should be used to represent underlying metadata about a process that's non-ephemeral - for example, the hostname of a process, or its instance ID.

Resources should be assigned to a tracer provider at its initialization, and are created much like attributes:

```go
resources := resource.NewWithAttributes(
	semconv.SchemaURL,
	semconv.ServiceNameKey.String("myService"),
	semconv.ServiceVersionKey.String("1.0.0"),
	semconv.ServiceInstanceIDKey.String("abcdef12345"),
)

provider := sdktrace.NewTracerProvider(
	...
	sdktrace.WithResource(resources),
)
```

Note the use of the `semconv` package to provide conventional names for resource attributes.  This helps ensure that consumers of telemetry produced with these semantic conventions can
easily discover relevant attributes and understand their meaning.

Resources can also be detected automatically through `resource.Detector` implementations.  These `Detector`s may discover information about the currently running process, the operating
system it is running on, the cloud provider hosting that operating system instance, or any number of other resource attributes.

```go
resources := resource.New(context.Background(),
	resource.WithFromEnv(), // pull attributes from OTEL_RESOURCE_ATTRIBUTES and OTEL_SERVICE_NAME environment variables
	resource.WithProcess(), // This option configures a set of Detectors that discover process information
	resource.WithDetectors(thirdparty.Detector{}), // Bring your own external Detector implementation
	resource.WithAttributes(attribute.String("foo", "bar")), // Or specify resource attributes directly
)
```

## OTLP endpoint

To send trace data to an OTLP endpoint (like the [collector](/docs/collector) or
Jaeger >= v1.35.0) you'll want to configure an OTLP exporter that sends to your endpoint.

### Using HTTP

```go
import (
  	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
  	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
)

func installExportPipeline(ctx context.Context) (func(context.Context) error, error) {
	client := otlptracehttp.NewClient()
	exporter, err := otlptrace.New(ctx, client)
	if err != nil {
		return nil, fmt.Errorf("creating OTLP trace exporter: %w", err)
	}
  	/* â€¦ */
}
```

To learn more on how to use the OTLP HTTP exporter, try out the [otel-collector](https://github.com/open-telemetry/opentelemetry-go/tree/main/example/otel-collector)

### Jaeger

To try out the OTLP exporter, since v1.35.0 you can run
[Jaeger](https://www.jaegertracing.io/)  as an OTLP endpoint and for trace
visualization in a docker container:

```shell
docker run -d --name jaeger \
  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \
  -e COLLECTOR_OTLP_ENABLED=true \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 4317:4317 \
  -p 4318:4318 \
  -p 14250:14250 \
  -p 14268:14268 \
  -p 14269:14269 \
  -p 9411:9411 \
  jaegertracing/all-in-one:latest
```

## Prometheus

Prometheus export is available in the `go.opentelemetry.io/otel/exporters/prometheus` package.

Please find more documentation on [GitHub](https://github.com/open-telemetry/opentelemetry-go/tree/main/exporters/prometheus)
